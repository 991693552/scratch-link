<!DOCTYPE html>
<html>
<head>
    <title>Scratch PB Test Client Fun Stuff Yay</title>
</head>
<body>
<div><label for="log">Log</label></div>
<textarea id="log" title="log" readonly style="width: 40rem; height: 10rem;"></textarea>
<div>
    <input id="follow" type="checkbox" title="Follow" checked>
    <label for="follow">Follow</label>
</div>
<div>
    <button id="init">Connect to app</button>
    <button id="go">Do a thing!</button>
    <button id="ping">Request ping</button>
</div>
<div>
    <button id="initBT">Connect to app (BT)</button>
    <button id="goBT">Do a (BT) thing!</button>
    <button id="beep">Yell!</button>
    <button id="closeBT">Goodbye</button>
</div>
<div>
    <input id="peripheralId" value="00-16-53-3d-05-04" type="text" placeholder="Peripheral id">
    <button id="connect">Make friends!</button>
</div>
<div>
    <input id="messageBody" value="DQAAAAAEAJkdAAAAAgFg" type="text" placeholder="data">
    <button id="send">Converse!</button>
</div>
</body>
<script>
    class JSONRPC {
        constructor() {
            this._requestID = 0;
            this._openRequests = {};
        }

        /**
         * Make an RPC Request and retrieve the result.
         * @param {string} method - the remote method to call
         * @param {object} params - the parameters to pass to the remote method
         * @returns {Promise} - a promise for the result of the call
         */
        sendRemoteRequest (method, params) {
            const requestID = this._requestID++;

            const promise = new Promise((resolve, reject) => {
                this._openRequests[requestID] = {resolve, reject};
            });

            this._sendRequest(method, params, requestID);

            return promise;
        }

        /**
         * Make an RPC Notification with no expectation of a result or callback.
         * @param {string} method - the remote method to call
         * @param {object} params - the parameters to pass to the remote method
         */
        sendRemoteNotification (method, params) {
            this._sendRequest(method, params);
        }

        /**
         * Handle an RPC request from remote.
         * @param {string} method - the method requested by the remote caller
         * @param {object} params - the parameters sent with the remote caller's request
         * @returns a result or Promise for result, if appropriate.
         */
        didReceiveCall (method, params) {
            throw new Error("Must override didReceiveCall");
        }

        /**
         * Send a JSON-style message object over the transport.
         * @param {object} jsonMessageObject - the message to send
         * @private
         */
        _sendMessage (jsonMessageObject) {
            throw new Error("Must override _sendMessage");
        }

        _sendRequest (method, params, id) {
            const request = {
                jsonrpc: "2.0",
                method,
                params
            };

            if (id != null) {
                request.id = id;
            }

            this._sendMessage(request);
        }

        _handleMessage (json) {
            if (json.jsonrpc !== '2.0') {
                throw new Error(`Bad or missing JSON-RPC version in message: ${stringify(json)}`);
            }
            if (json.hasOwnProperty('method')) {
                this._handleRequest(json);
            } else {
                this._handleResponse(json);
            }
        }

        _sendResponse (id, result, error) {
            const response = {
                jsonrpc: '2.0',
                id
            };
            if (error != null) {
                response.error = error;
            } else {
                response.result = result || null;
            }
            this._sendMessage(response);
        }

        _handleResponse (json) {
            const {result, error, id} = json;
            const openRequest = this._openRequests[id];
            delete this._openRequests[id];
            if (error) {
                openRequest.reject(error);
            } else {
                openRequest.resolve(result);
            }
        }

        _handleRequest (json) {
            const {method, params, id} = json;
            const rawResult = this.didReceiveCall(method, params);
            if (id != null) {
                Promise.resolve(rawResult).then(
                    result => {
                        this._sendResponse(id, result);
                    },
                    error => {
                        this._sendResponse(id, null, error);
                    }
                );
            }
        }
    }

    class JSONRPCWebSocket extends JSONRPC {
        constructor (webSocket) {
            super();

            this._ws = webSocket;
            this._ws.onmessage = e => this._onSocketMessage(e);
            this._ws.onopen = e => this._onSocketOpen(e);
            this._ws.onclose = e => this._onSocketClose(e);
            this._ws.onerror = e => this._onSocketError(e);
        }

        dispose () {
            this._ws.close();
            this._ws = null;
        }

        _onSocketOpen (e) {
            addLine(`WS opened: ${stringify(e)}`);
        }

        _onSocketClose (e) {
            addLine(`WS closed: ${stringify(e)}`);
        }

        _onSocketError (e) {
            addLine(`WS error: ${stringify(e)}`);
        }

        _onSocketMessage (e) {
            addLine(`Received message: ${e.data}`);
            const json = JSON.parse(e.data);
            this._handleMessage(json);
        }

        _sendMessage (message) {
            const messageText = JSON.stringify(message);
            addLine(`Sending message: ${messageText}`);
            this._ws.send(messageText);
        }
    }

    class ScratchBLE extends JSONRPCWebSocket {
        constructor () {
            super(new WebSocket('ws://localhost:20110/scratch/ble'));
        }

        requestDevice (options) {
            return this.sendRemoteRequest('discover', options);
        }

        didReceiveCall (method, params) {
            switch (method) {
                case 'didDiscoverPeripheral':
                    addLine(`Peripheral discovered: ${stringify(params)}`);
                    break;
                case 'ping':
                    return 42;
            }
        }
    }

    class ScratchBT extends JSONRPCWebSocket {
        constructor () {
            super(new WebSocket('ws://localhost:20110/scratch/bt'));
        }

        requestDevice (options) {
            return this.sendRemoteRequest('discover', options);
        }

        connectDevice (options) {
            return this.sendRemoteRequest('connect', options);
        }

        sendMessage (options) {
            return this.sendRemoteRequest('send', options);
        }

        didReceiveCall (method, params) {
            switch (method) {
                case 'didDiscoverPeripheral':
                    addLine(`Peripheral discovered: ${stringify(params)}`);
                    break;
                case 'didReceiveMessage':
                    addLine(`Message received from peripheral: ${stringify(params)}`);
                    break;
                default:
                    return 'nah';
            }
        }
    }

    self.Scratch = self.Scratch || {};

    function init () {
        addLine('Connecting...');
        self.Scratch.BLE = new ScratchBLE();
        addLine('Connected.');
    }

    function initBT () {
        addLine('Connecting...');
        self.Scratch.BT = new ScratchBT();
        addLine('Connected.');
    }

    function go() {
        Scratch.BLE.requestDevice({
            filters: [
                { services: ['4cdbbd87-d6e6-46c2-9d0b-df87551e159a'] },
                { services: ['continuous_glucose_monitoring', 'mesh_proxy'] },
                { name: 'wholeName' },
                { namePrefix: 'prefixOfName' }
            ],
            optionalServices: ['battery_service']
        }).then(
            x => {
                addLine(`requestDevice resolved to: ${stringify(x)}`);
            },
            e => {
                addLine(`requestDevice rejected with: ${stringify(e)}`);
            }
        );
    }

    function goBT () {
        Scratch.BT.requestDevice({
            majorDeviceClass: 8,
            minorDeviceClass: 1
        }).then(
            x => {
                addLine(`requestDevice resolved to: ${stringify(x)}`);
            },
            e => {
                addLine(`requestDevice rejected with: ${stringify(e)}`);
            }
        );
    }

    function requestPing() {
        Scratch.BLE.sendRemoteRequest('pingMe').then(
            x => {
                addLine(`Ping request resolved with: ${stringify(x)}`);
            },
            e => {
                addLine(`Ping request rejected with: ${stringify(e)}`);
            }
        );
    }

    function connect (peripheralId) {
        Scratch.BT.connectDevice({
            peripheralId: peripheralId
        }).then(
            x => {
                addLine(`connectDevice resolved to: ${stringify(x)}`);
            },
            e => {
                addLine(`connectDevice rejected with: ${stringify(e)}`);
            }
        );
    }

    function sendMessage (message) {
        Scratch.BT.sendMessage({
            message: message,
            encoding: 'base64'
        }).then(
            x => {
                addLine(`sendMessage resolved to: ${stringify(x)}`);
            },
            e => {
                addLine(`sendMessage rejected with: ${stringify(e)}`);
            }
        );
    }

    function stringify(o) {
        return JSON.stringify(o, o && Object.getOwnPropertyNames(o));
    }

    const follow = document.getElementById('follow');
    const log = document.getElementById('log');

    const goButton = document.getElementById('go');
    goButton.onclick = () => {
        try {
            go();
        } catch (e) {
            addLine(`Go button caught exception: ${stringify(e)}`);
        }
    };

    const goBTButton = document.getElementById('goBT');
    goBTButton.onclick = () => {
        try {
            goBT();
        } catch (e) {
            addLine(`Go BT button caught exception: ${stringify(e)}`);
        }
    };

    const initButton = document.getElementById('init');
    initButton.onclick = () => {
        try {
            init();
        } catch (e) {
            addLine(`Init button caught exception: ${stringify(e)}`);
        }
    };

    const initBTButton = document.getElementById('initBT');
    initBTButton.onclick = () => {
        try {
            initBT();
        } catch (e) {
            addLine(`Init BT button caught exception: ${stringify(e)}`);
        }
    };

    const pingButton = document.getElementById('ping');
    pingButton.onclick = () => {
        try {
            requestPing();
        } catch (e) {
            addLine(`Ping button caught exception: ${stringify(e)}`);
        }
    };

    const connectButton = document.getElementById('connect');
    connectButton.onclick = () => {
        try {
            const peripheralId = document.getElementById('peripheralId');
            connect(peripheralId.value);
        } catch (e) {
            addLine(`Connect button caught exception: ${stringify(e)}`);
        }
    };

    const beepButton = document.getElementById('beep');
    beepButton.onclick = () => {
        try {
            sendMessage("DwAAAIAAAJQBgQKC6AOC6AM=");
        } catch (e) {
            addLine(`Send button caught exception: ${stringify(e)}`);
        }
    }

    const sendButton = document.getElementById('send');
    sendButton.onclick = () => {
        try {
            const data = document.getElementById('messageBody');
            sendMessage(data.value);
        } catch (e) {
            addLine(`Send button caught exception: ${stringify(e)}`);
        }
    }

    const closeButton = document.getElementById('closeBT');
    closeButton.onclick = () => {
        self.Scratch.BT.dispose();
    }

    function addLine(text) {
        log.innerHTML += `${text}\n`;
        if (follow.checked) {
            log.scrollTop = log.scrollHeight;
        }
    }

</script>
</html>
